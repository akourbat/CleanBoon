#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

Usings

#!csharp

#r "nuget: System.Reactive, 6.0.1"
#r "nuget: Microsoft.Reactive.Testing, 6.0.1"
#r "nuget: System.Reactive.Linq, 6.0.1"
using System.Reactive;
using System.Collections;
using System.Collections.Generic;
using System.Reactive.Linq;
using System.Reactive.Concurrency;
using Microsoft.Reactive.Testing;
using System;
using System.Linq;
using System.Globalization;

#!markdown

Models

#!csharp

public enum MessageType{ BOON, CONDI}
public enum BoonType{ MIGHT, FURY, PROT, STAB, QUICK, ALAC, SWIFT, REGEN, RESIL}

public record MessageBase(string UserId, MessageType type);

public record BoonBase(string UserId, BoonType Type, int DurationMs) : MessageBase(UserId, MessageType.BOON)
{ 
    public int Elapsed { get; set; }
    public bool CancelEffect {get; init;} = false;
}
public record BoonPeriodic(string UserID, BoonType Type, int DurationMs, int TickValue): BoonBase(UserID, Type, DurationMs);
public record BoonStack(string UserID, BoonType Type, int DurationMs, int StackSize): BoonBase(UserID, Type, DurationMs);

#!markdown

Logic

#!csharp

public static int MaxQueueSize = 10;
public static int MaxTicks = 10;

public static PriorityQueue<int,int> ComputeRegenTicks(PriorityQueue<int, int> acc, IList<BoonPeriodic> effects) 
{  
    if(effects is []) return acc;
    else if(effects.Any(x => x.CancelEffect == true)) {acc.Clear(); return acc;}
    else
    {   
        var range = effects
            .Select(x => Enumerable.Repeat((x.TickValue, x.TickValue), (int)(x.DurationMs/1000)))
            .SelectMany(x => x).ToList();
        acc.EnqueueRange(range);
        if(acc.Count > MaxQueueSize)
        {
            var newRange = acc.UnorderedItems.OrderByDescending(x => x.Element).Take(MaxQueueSize).ToList();
            acc.Clear();
            acc.EnqueueRange(newRange);
        }
        return acc; 
    }
}
public static T InsertTimeElapsed<T>(TimeInterval<T> effect) where T: BoonBase
{ 
    effect.Deconstruct(out T value, out TimeSpan interval);
    value.Elapsed = (int)interval.TotalMilliseconds;
    return value; 
}
public static int ComputeActualDelay<T>(int acc, T effect, int cutoff) where T: BoonBase
{
    if(effect.CancelEffect is true) return 0;
    else if (acc == 0 || effect.Elapsed > acc) 
    {
        return effect.DurationMs;
    }
    else{
        var updated = acc - effect.Elapsed + effect.DurationMs;
        return updated > cutoff ? cutoff : updated;
    }
}
public static TimeSpan Round(this TimeSpan ts, TimeSpan rnd) {
if (rnd == TimeSpan.Zero)
    return ts;
else {
    var rndTicks = rnd.Ticks;
    var ansTicks = ts.Ticks + Math.Sign(ts.Ticks) * rndTicks / 2;
    return TimeSpan.FromTicks(ansTicks - ansTicks % rndTicks);
    }
}
public static TimeSpan Round(this TimeSpan ts) => ts.Round(TimeSpan.FromSeconds(1));

#!markdown

Regen Calculations

#!csharp

BoonBase tick4 = new BoonPeriodic ("first", BoonType.RESIL, 5500, 5);
BoonBase tick5 = new BoonPeriodic("second", BoonType.RESIL, 6000, 10);
BoonBase tick6 = new BoonPeriodic("third", BoonType.RESIL, 3000, 8);
BoonBase tick7 = new BoonBase("third", BoonType.ALAC, 4000);
BoonBase tickCancel = new BoonPeriodic ("cancel", BoonType.RESIL, 0, 0) {CancelEffect = true};

private const int MaxQueueSize = 20;
private const int MaxTicks = 10;
public class IntMaxComparer: IComparer<int> { public int Compare(int x, int y) => y.CompareTo(x); }

var scheduler3 = new TestScheduler();
var sourcePQ = scheduler3.CreateHotObservable(
    new Recorded<Notification<BoonBase>>(300, Notification.CreateOnNext(tick4)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(1.4).Ticks, Notification.CreateOnNext(tick5)),
    //new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(6).Ticks, Notification.CreateOnNext(tickCancel)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(14.5).Ticks, Notification.CreateOnNext(tick6)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(3).Ticks, Notification.CreateOnNext(tick7)));

// Single pipeline version with .Repeat()
var singlePipeline = sourcePQ.OfType<BoonPeriodic>()
                        .Publish(w => w.Take(1)
                                .Select(x => new List<BoonPeriodic>{x})
                                .Concat(w.Buffer(TimeSpan.FromSeconds(1), scheduler3)))
                        .Scan(new PriorityQueue<int,int>(MaxQueueSize+5, new IntMaxComparer()), (acc, effects) =>
                                    ComputeRegenTicks(acc, effects))
                        .Select(acc => acc.TryDequeue(out int tick, out int priority) ? (acc.Count, tick) : (0,0))
                        .TakeUntil(x => x.Item1 == 0)
                        .Repeat();

//Version with Windows - keeps doing buffers (which is incorrect)
var windowed = sourcePQ.OfType<BoonPeriodic>()
                        .Publish(w => w.Take(1)
                                .Select(x => new List<BoonPeriodic>{x})
                                .Concat(w.Buffer(TimeSpan.FromSeconds(1), scheduler3)))
                        .Scan(new PriorityQueue<int,int>(MaxQueueSize+5, new IntMaxComparer()), (acc, effects) =>
                                    ComputeRegenTicks(acc, effects))
                        .Select(acc => acc.TryDequeue(out int tick, out int priority) ? (acc.Count, tick) : (0,0))
                        .Publish().RefCount();

var ver2 = sourcePQ.Window(windowed.Where(x => x.Item1 == 0)).SelectMany(w => windowed);
                
var testObserver3 = scheduler3.Start(() => singlePipeline, 0L, 200L, TimeSpan.FromSeconds(30).Ticks);

Console.WriteLine("Time is {0} ticks", scheduler3.Clock);
Console.WriteLine("Received {0} notifications", testObserver3.Messages.Count);

foreach (Recorded<Notification<(int, int)>> message in testObserver3.Messages)
{
    Console.WriteLine($"  {message.Value.Value.Item1} count for {message.Value.Value.Item2} HP -> recorded on {(message.Time/10000).ToString("N1", CultureInfo.InvariantCulture)} millisecond");
}

#!markdown

Stacking Durations

#!csharp

var tick1 = new BoonBase("alex", BoonType.MIGHT, 3000);
var tick2 = new BoonBase("dima", BoonType.FURY, 8000);
var tick3 = new BoonBase("olga", BoonType.STAB, 4000);
var cancelF = new BoonBase("admin", BoonType.STAB, 0){CancelEffect = true};

var scheduler = new TestScheduler();
var source = scheduler.CreateHotObservable(
    new Recorded<Notification<BoonBase>>(300, Notification.CreateOnNext(tick1)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(2).Ticks, Notification.CreateOnNext(tick2)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(8).Ticks, Notification.CreateOnNext(cancelF)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(16).Ticks, Notification.CreateOnNext(tick3)));

var scanned = source
            .TimeInterval(scheduler)
            .Select(x => InsertTimeElapsed<BoonBase>(x))
            .Scan( 0, (acc, x) => ComputeActualDelay(acc, x, 10000))
            .Select(x => Observable.Return(("start", x))
                .Concat(Observable.Return(("end", 0))
                .Delay(TimeSpan.FromMilliseconds(x), scheduler)))
            .Switch();

var testObserver = scheduler.Start(() => scanned, 0L, 200L, TimeSpan.FromSeconds(40).Ticks);

Console.WriteLine("Time is {0} ticks", scheduler.Clock);
Console.WriteLine("Received {0} notifications", testObserver.Messages.Count);

foreach (Recorded<Notification<(string, int)>> message in testObserver.Messages)
{
    Console.WriteLine($"  {message.Value.Value.Item1} for {message.Value.Value.Item2/1000} seconds -> recorded on {TimeSpan.FromTicks(message.Time).TotalMilliseconds} second");
}

#!markdown

Stacking Intensity

#!csharp

BoonBase tick10 = new BoonStack("alex", BoonType.MIGHT, 3000, 15);
BoonBase tick12 = new BoonStack("dima", BoonType.FURY, 8000, 18);
BoonBase tick14 = new BoonStack("olga", BoonType.STAB, 4000, 10);
BoonBase tickCancel = new BoonStack ("cancel", BoonType.RESIL, 0, 0) {CancelEffect = true};

var schedulerStack = new TestScheduler();
var sourceStacked = schedulerStack.CreateHotObservable(
    new Recorded<Notification<BoonBase>>(300, Notification.CreateOnNext(tick10)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(1.5).Ticks, Notification.CreateOnNext(tick12)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(4.8).Ticks, Notification.CreateOnNext(tickCancel)),
    new Recorded<Notification<BoonBase>>(TimeSpan.FromSeconds(6).Ticks, Notification.CreateOnNext(tick14)));

var sourcePublished = sourceStacked.Publish().RefCount();

var withCancel = sourcePublished.OfType<BoonStack>()
                    .Where(x => x.CancelEffect is true)
                    .Select(x => x)
                    .Publish().RefCount();

var stacked = sourcePublished.OfType<BoonStack>()
                .Window(withCancel)
                .SelectMany(w => w.SelectMany(x => Observable.Return(x.StackSize)
                                    .Concat(Observable.Return(-1* x.StackSize)
                                        .Delay(TimeSpan.FromMilliseconds(x.DurationMs), schedulerStack)))
                                    .Scan(0, (acc, stacks) => acc + stacks)
                                    .Select( x => x > 25 ? 25 : x )
                                    .Append(0)
                                    .TakeUntil(withCancel));
                    
var testObserverStacked = schedulerStack.Start(() => stacked, 0L, 200L, TimeSpan.FromSeconds(25).Ticks); 
testObserverStacked.Messages           
